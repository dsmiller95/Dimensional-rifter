using Assets.WorldObjects.SaveObjects;
using Assets.WorldObjects.SaveObjects.SaveManager;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Assets.Tiling.Tilemapping
{
    public class CombinationTileMapManager : MonoBehaviour, ISaveable<WorldSaveObject>
    {
        /// <summary>
        /// used when loading tileMaps from save
        /// </summary>
        public TileMapConfigurationData[] tileMapConfig;
        private Dictionary<CoordinateType, TileMapConfigurationData> _configDataDict;
        private Dictionary<CoordinateType, TileMapConfigurationData> ConfigDataDict
        {
            get
            {
                if (_configDataDict == null)
                {
                    _configDataDict = tileMapConfig.ToDictionary(x => x.coordinateType);
                }
                return _configDataDict;
            }
        }

        public TileMapPreviewsByCoordinateRangeType previewPrefabIndex;

        /// <summary>
        /// the most "On Top" region is at index N, all regions at a lower index will avoid overlapping with it
        /// </summary>
        [Tooltip("Generated by map gen, loaded from save")]
        public List<TileMapRegionRenderer> regionBehaviors;

        public UniversalCoordinateSystemMembers everyMember;

        public TileMapRegion regionBehaviorPrefab;

        #region Singleton management
        public static CombinationTileMapManager instance;
        private void Awake()
        {
            if (instance != null)
            {
                Debug.LogError("Instance already registered, combination tile map manager is singleton-y");
            }
            instance = this;
            SaveSystemHooks.Instance.PreLoad += ClearInstance;
        }

        private void ClearInstance()
        {
            instance = null;
        }
        #endregion

        private bool RenderParemeterChangeRegistered = false;
        public void OnRegionRenderParametersChanged()
        {
            RenderParemeterChangeRegistered = true;
        }
        private void Update()
        {
            if (RenderParemeterChangeRegistered)
            {
                RenderParemeterChangeRegistered = false;
                OnRegionPlaneDataChanged();
            }
        }

        private void OnRegionPlaneDataChanged()
        {
            SortByPlaneID();
            foreach (var region in regionBehaviors)
            {
                var configData = ConfigDataDict[region.MyOwnData.baseRange.CoordinateType];
                region.InitializeForTopologyBake(configData, everyMember);
            }

            everyMember.readWriteLock.OpenForEdit();
            foreach (var region in regionBehaviors)
            {
                var configData = ConfigDataDict[region.MyOwnData.baseRange.CoordinateType];
                configData.atomataSystem.ExecuteOnRegion(this, region.MyOwnData);
            }

            BakeAllTileMapMeshes();
        }

        public void DestroyRegion(short regionId)
        {
            var regionIndex = GetIndexFromTileID(regionId);
            var behavior = regionBehaviors[regionIndex];
            regionBehaviors.RemoveAt(regionIndex);
            Destroy(behavior.gameObject);
        }

        private int GetIndexFromTileID(short tileId)
        {
            return regionBehaviors.FindIndex(region => region.MyOwnData.baseRange.CoordinatePlaneID == tileId);
        }

        #region Previewing

        public TileMapRegionPreview SpawnNewPreviewBehavior(TileMapRegionData initialData)
        {
            if (!previewPrefabIndex.keyedPrefabs.TryGetValue(initialData.baseRange.rangeType, out var prefabSource))
            {
                throw new System.Exception("prefab for range type not found");
            }
            var newPreview = Instantiate(prefabSource.prefab, transform);
            newPreview.MyOwnData = initialData;
            newPreview.InitializeForTopologyBake(ConfigDataDict[initialData.baseRange.CoordinateType], everyMember);

            newPreview.BakeTopology(initialData, new TileMapRegionRenderer[0]);
            newPreview.SetupBoundingCollider(initialData);

            SetPreviewColors();
            return newPreview;
        }

        public void SetPreviewRegionData(TileMapRegionPreview previewBehavior)
        {
            previewBehavior.BakeTopology(previewBehavior.MyOwnData, new TileMapRegionRenderer[0]);
            previewBehavior.SetupBoundingCollider(previewBehavior.MyOwnData);
            SetPreviewColors();
        }
        public void ClosePreviewRegion(TileMapRegionPreview previewBehavior)
        {
            Destroy(previewBehavior.gameObject);
            SetPreviewColors();
        }

        public UniversalCoordinate ClosestNonPreviewValidCoordinate(Vector2 position)
        {
            var minDistance = float.MaxValue;
            UniversalCoordinate minCoordinate = default;
            foreach (var region in regionBehaviors)
            {
                var coord = region.MyOwnData.GetClosestValidCoordinate(position);
                if (!coord.IsValid())
                {
                    continue;
                }
                var coordsPosition = PositionInRealWorld(coord);
                var dist = Vector2.Distance(coordsPosition, position);
                if (dist < minDistance)
                {
                    minDistance = dist;
                    minCoordinate = coord;
                }
            }
            return minCoordinate;
        }

        private void SetPreviewColors()
        {
            var previews = GetComponentsInChildren<TileMapRegionPreview>();
            if (previews.Length <= 0)
            {
                for (var i = 0; i < regionBehaviors.Count; i++)
                {
                    if (regionBehaviors[i] is TileMapRegion region)
                    {
                        region.SetNoPreviews(region.MyOwnData);
                    }
                }
            }
            else
            {
                for (var i = 0; i < regionBehaviors.Count; i++)
                {
                    if (regionBehaviors[i] is TileMapRegion region)
                    {
                        region.SetPreviewOnCollidesWith(region.MyOwnData, previews);
                    }
                }
            }
        }
        #endregion

        private void SortByPlaneID()
        {
            regionBehaviors = regionBehaviors.OrderBy(x => x.MyOwnData.baseRange.CoordinatePlaneID).ToList();
        }

        private void OnDestroy()
        {
            if (instance == this)
            {
                instance = null;
            }
            SaveSystemHooks.Instance.PreLoad -= ClearInstance;
        }

        private void BakeAllTileMapMeshes()
        {
            var startFromIndex = regionBehaviors.Count - 1;
            for (var regionIndex = startFromIndex; regionIndex >= 0; regionIndex--)
            {
                var regionBehavior = regionBehaviors[regionIndex];
                if (regionBehavior.MyOwnData.preview)
                {
                    return;
                }

                regionBehavior.BakeTopology(regionBehavior.MyOwnData, regionBehaviors.Skip(regionIndex + 1));
                regionBehavior.SetupBoundingCollider(regionBehavior.MyOwnData);
            }
        }


        #region Coordinate Access
        public Vector2 PositionInRealWorld(UniversalCoordinate coordinate)
        {
            var regionIndex = GetIndexFromTileID(coordinate.CoordinatePlaneID);
            var planeData = regionBehaviors[regionIndex].MyOwnData;
            return planeData.coordinateTransform.MultiplyPoint3x4((Vector2)coordinate.ToPositionInPlane());
        }

        public bool ValidCoordinateInOwnPlane(UniversalCoordinate coordinate)
        {
            var regionIndex = GetIndexFromTileID(coordinate.CoordinatePlaneID);
            if (regionIndex == -1)
            {
                return false;
            }
            var planeData = regionBehaviors[regionIndex].MyOwnData;
            return planeData.IsValidInThisPlane(coordinate);
        }

        public UniversalCoordinate? GetValidCoordinateFromWorldPosIfExists(Vector2 worldPosition)
        {
            for (short regionIndex = 0; regionIndex < regionBehaviors.Count; regionIndex++)
            {
                var planeData = regionBehaviors[regionIndex].MyOwnData;
                var coordOpt = planeData.GetCoordinateFromRealPositionIffValid(worldPosition);
                if (coordOpt.HasValue)
                {
                    return coordOpt.Value;
                }
            }
            return null;
        }

        public UniversalCoordinate GetCoordinateOnSamePlane(Vector2 worldPosition, UniversalCoordinate otherCoordinate)
        {
            var regionIndex = GetIndexFromTileID(otherCoordinate.CoordinatePlaneID);
            var planeData = regionBehaviors[regionIndex].MyOwnData;
            return planeData.GetCoordinateFromRealPosition(worldPosition);
        }
        #endregion

        public TileMapRegion CreateNewRegion(TileMapRegionData regionData)
        {
            var region = Instantiate(regionBehaviorPrefab, transform);
            region.MyOwnData = regionData;
            short newPlaneId = (short)(regionBehaviors.Max(r => r.MyOwnData.baseRange.CoordinatePlaneID) + 1);
            region.MyOwnData.baseRange.CoordinatePlaneID = newPlaneId;

            regionBehaviors.Add(region);

            return region;
        }

        public WorldSaveObject GetSaveObject()
        {
            var allRegionSaveData = regionBehaviors
                .Select(data => data.MyOwnData.Serialize())
                .Where(x => x != null);

            return new WorldSaveObject
            {
                regions = allRegionSaveData.ToList(),
                members = everyMember.GetSaveObject()
            };
        }

        public void SetupFromSaveObject(WorldSaveObject save)
        {
            regionBehaviors = save.regions
                .Select(saved => TileMapRegionData.Deserialize(saved))
                .Select(regionData =>
                {
                    var region = Instantiate(regionBehaviorPrefab, transform);
                    region.MyOwnData = regionData;

                    return region as TileMapRegionRenderer;
                }).ToList();
            everyMember.SetupFromSaveObject(save.members);

            RenderParemeterChangeRegistered = true;
        }

    }
}
